# 1309. 동물원(실버 1)

### 풀이 일자

2024년 7월 4일

## 알고리즘 분류

- 다이나믹 프로그래밍

## 내 풀이 방향

처음에는 사진처럼 경우의 수를 나누어서 구해보려고 시도했었다. 그러나 문제에서 예시로 준 `4`를 대입했을 때 `41`이 아닌 전혀 다른 값이 나와서 새로운 방법을 찾아야 된다는 것을 알게 되었다.  
![문제풀이 이미지](/images/boj1309.jpg)  
이 방식으로는 명확한 규칙을 찾을 수 없는 비효율적인 풀이가 된다.  
그래서 [문어박사님의 강의](https://www.youtube.com/watch?v=y---0o49cKI&list=PLodgw23vNd_XF2VWJtog1Nw4r_isWb5Uw&index=20)를 참고해서 아래와 같이 풀이하였다.

## 문어박사님의 풀이

### 문제에 대한 설명

문제에서 `한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.`를 주목해서 문어박사님은 dp 배열을 3\*n 배열로 가정하고 문제를 풀이하였다. 아래의 예시 표는 4칸 표를 가정하고 풀이하였다.
| | 0 | 1 | 2 |
|--- |---- |---- |---- |
| 0 | 1 | 1 | 1 |
| 1 | 3 | 2 | 2 |
| 2 | 7 | 5 | 5 |
| 3 | 17 | 12 | 12 |

`dp[i][j]`는 2\*i 길이의 무리의 j 위치에 배치하는 방법의 수를 의미한다.  
`dp[i][0]`의 경우 j 위치에 아무것도 배치하지 않는 경우를 생각하기 때문에 `[i-1][1]`번에 배치하는 경우와 `[i-1][2]`에 배치하는 경우 모두를 가져올 수 있다. 그러나 `dp[i][1]`이나 `dp[i][2]`의 경우 다른 쪽애 배치하는 경우를 가져올 수 없다. 그래서 아래와 같이 코드를 작성하였다.

### 첫 번째 풀이방식(메모리 초과)

```python
n = int(input())

dp = [[1] * 3 for _ in range(n)]

for i in range(1, n):
    dp[i][0] = sum(dp[i-1])
    dp[i][1] = dp[i-1][0] + dp[i-1][2]
    dp[i][2] = dp[i-1][0] + dp[i-1][1]

print(sum(dp[-1]) % 9901)
```

이 경우에는 메모리 초과가 발생하였다. 이 문제의 경우 n의 범위가 `N(1≤N≤100,000)`으로 10만까지 가기 때문에 숫자가 기하급수적으로 늘어나게 된다. 그래서 아래의 두 가지 풀이방법을 통해서 메모리 초과를 해결하였다.

### 두 번째 풀이방식(메모리 초과 해결)

```python
n = int(input())

dp = [[1] * 3 for _ in range(n)]

for i in range(1, n):
    dp[i][0] = sum(dp[i-1]) % 9901
    dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901
    dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % 9901

print(sum(dp[-1]) % 9901)
```

이 경우에는 2차원 배열을 그대로 이용하되, 매번 계산할 때마다 9901로 나누어 주어 들어가는 숫자의 범위를 조정하였다. 이 경우에 사용한 메모리는 `120408 KB`, 시간은 `144 ms`로 해결할 수 있었다.

### 세 번째 풀이방식(메모리 초과 해결)

```python
n = int(input())
n0 = n1 = n2 = 1
for i in range(1, n):
    n0, n1, n2 = (n0+n1+n2)%9901, (n0+n2)%9901, (n0+n1)%9901
ans = n0+n1+n2
print(ans%9901)
```

꼭 2차원 배열을 이용할 필요는 없다. 그냥 매번 변수의 값을 개선해서 풀이하는 방식이다. 이 경우도 메모리 초과를 해결할 수 있었지만 이 문제의 경우에는 앞선 두 번째 풀이방식과 비교했을 때 비약적인 메모리 사용량 개선 효과는 나타나지 않았다. 메모리는 `109240 KB`, 시간은 `116 ms`로 해결하였다.

## 총평

실버1인데 실버1 치고도 (내 기준) 생각해야 될 포인트가 많은 문제였다. 아직 내가 DP에 익숙하지 않아서 그런 것 같은데, 더 많은 DP 문제를 생각해보고 풀이하면서 요령 있게 풀어야겠다는 생각을 하게 해줬다.
